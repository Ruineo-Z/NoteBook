# 企业级 Agent 实战路线图：人机协作小说创作平台（3 个月）

---

## 目标

用 LangChain + LangGraph 构建一个人机协作的小说创作平台，通过真实场景练习企业级 Agent 的核心能力。

**MVP 目标**：
1. 通过多轮对话帮用户设计世界观（从模糊想法到具体设定）
2. 根据世界观逐章创作小说（支持修改和重写）
3. 保存世界观、章节内容、创作历史

**核心特点**：人机协作，不是全自动生成

---

## 核心挑战

### 上下文管理的矛盾

**问题**：
- 创作第 1 章：用户和 Agent 对话 10 轮修改，上下文 5000 tokens
- 创作第 2 章：需要第 1 章的信息，但如果加载完整对话历史，上下文会爆炸
- 创作第 10 章：如果加载前 9 章的完整对话历史，上下文早就超限了

**解决方案：分层状态管理**
- **创作态**（临时）：当前章节的完整对话历史
- **确认态**（持久）：用户确认后，压缩成最终版本 + 关键信息

**具体做法**：
1. 写第 1 章时：保留完整对话（用户的反馈、修改意图、Agent 的多次生成）
2. 用户确认第 1 章后：压缩成"第 1 章最终版本 + 关键信息（新出现的人物、剧情转折、伏笔）"
3. 写第 2 章时：只加载压缩后的第 1 章信息，不加载对话历史

**这是企业级 Agent 和普通 Agent 的核心区别之一。**

---

## 阶段 0：现状盘点与场景设计（第 1 周）

**目标**：明确能力现状，设计 MVP 场景

**要做的事**：
1. 盘点现有能力
   - 你现在用 LangChain 写过什么 Agent？
   - 能做到什么程度？（单轮/多轮、有无工具调用、有无状态管理）
   - 遇到过什么问题？

2. 设计 MVP 场景
   - **世界观设计**：
     - 输入：用户的模糊想法（"我想写一个科幻小说"）
     - 过程：Agent 通过多轮对话帮用户具体化（题材、背景、主角、冲突）
     - 输出：完整的世界观文档（可以开始写作）

   - **章节创作**：
     - 输入：世界观 + 当前章节号
     - 过程：Agent 生成章节 → 用户修改/重写 → 确认
     - 输出：最终版本的章节

   - **不做**：
     - 不做多部作品管理（只做单部小说）
     - 不做自动评估质量（人工评估）
     - 不做复杂的协作（只有用户和 Agent，没有多个 Agent）

3. 搭建最简单的版本
   - 用 LangChain 写一个能跑的 Demo
   - 功能：用户输入想法 → Agent 问几个问题 → 生成世界观 → 生成第 1 章
   - 不管质量，先跑通

**产出**：
- 能力现状文档（你现在会什么、不会什么）
- MVP 场景设计文档（输入输出格式、交互流程、不做什么）
- 最简 Demo（能跑，但质量差）

**判断标准**：
- Demo 能完成一次完整流程（世界观设计 → 生成第 1 章）
- 你知道这个 Demo 的问题在哪

---

## 阶段 1：上下文管理（第 2-3 周）

**目标**：实现分层状态管理，解决上下文爆炸问题

**现在的问题**：
- 最简 Demo 没有状态管理，每次对话都是独立的
- 或者：把所有对话历史都保存，导致上下文快速增长

**要做的事**：

### 1. 设计状态结构

**世界观状态**：
- 题材、背景、时代
- 主要人物（名字、性格、关系、目标）
- 核心冲突
- 世界规则（如果是奇幻/科幻）

**章节状态**：
- 创作态（临时）：
  - 当前章节的完整对话历史
  - 用户的反馈和修改意图
  - Agent 的多次生成结果

- 确认态（持久）：
  - 章节最终版本（文本）
  - 关键信息提取：
    - 新出现的人物
    - 剧情转折点
    - 埋下的伏笔
    - 时间/地点变化

**全局状态**：
- 世界观
- 所有章节的确认态（不包括创作态）
- 当前创作进度（正在写第几章）

### 2. 实现状态管理

**技术选择**：
- 用 LangGraph 的 State（推荐，因为需要复杂的状态转换）
- 或者用 LangChain 的 Memory + 自定义状态存储

**关键实现**：
- **状态压缩**：用户确认章节后，调用 LLM 提取关键信息
  - Prompt：从这段对话和最终章节中，提取：新人物、剧情转折、伏笔、时间地点变化
  - 输出：结构化的关键信息（JSON 格式）

- **状态加载**：开始新章节时，只加载：
  - 世界观
  - 前面所有章节的确认态（最终版本 + 关键信息）
  - 不加载：前面章节的创作态（对话历史）

### 3. 验证状态管理

**测试场景**：
- 写 3 章小说
- 每章对话 5-10 轮
- 检查：
  - 第 3 章能否记住第 1 章的人物和剧情
  - 第 3 章的上下文是否包含第 1 章的完整对话历史（不应该包含）
  - 上下文 token 数是否可控

**产出**：
- 状态结构设计文档
- 状态压缩和加载的实现代码
- 测试报告（上下文 token 数统计）

**判断标准**：
- 写 3 章小说，第 3 章能记住前面的关键信息
- 第 3 章的上下文 token 数 < 10000（可调整）
- 人物名字、剧情不会前后矛盾

---

## 阶段 2：观测性（第 4-5 周）

**目标**：看清 Agent 每一步在做什么，特别是状态的变化

**现在的问题**：
- Agent 生成的内容质量不稳定
- 不知道是 Prompt 的问题、状态管理的问题、还是 LLM 的问题
- 状态压缩后，不知道丢失了什么信息

**要做的事**：

### 1. 记录每一步的输入输出

**记录内容**：
- 每次调用 LLM 时：
  - Prompt（完整的）
  - 输入的状态（世界观、已写章节的确认态）
  - LLM 返回的内容
  - Token 消耗

- 状态变化时：
  - 状态压缩前：完整的对话历史
  - 状态压缩后：提取的关键信息
  - 对比：丢失了什么信息

**日志格式**：
- 结构化日志（JSON）
- 每个任务有唯一 ID
- 每一步有时间戳和步骤编号

### 2. 实现任务回放

**功能**：
- 给定一个任务 ID，能重新看到：
  - 完整的对话流程
  - 每一步的 Prompt 和输出
  - 状态的变化过程

**用途**：
- 调试：为什么这一章生成得不好？
- 优化：哪些信息在状态压缩时丢失了？

### 3. 统计指标

**基础指标**：
- 成功率：生成的章节是否符合要求（人工评估）
- Token 消耗：每章平均消耗多少 Token
- 对话轮数：每章平均需要多少轮对话

**状态管理指标**：
- 状态压缩率：压缩前后的 token 数对比
- 信息保留率：关键信息是否被正确提取（人工抽查）

**产出**：
- 结构化日志示例
- 任务回放功能演示
- 指标统计报告

**判断标准**：
- 给定一个任务，能看到每一步的 Prompt、状态、输出
- 能统计出 Token 消耗和状态压缩率
- 能发现至少 1 个状态管理的问题（比如某些关键信息被丢失）

---

## 阶段 3：迭代优化（第 6-7 周）

**目标**：根据观测结果优化 Agent

**现在的问题**：
- 有了观测性，能看到问题，但不知道怎么改

**要做的事**：

### 1. 分析失败案例

**找出问题**：
- 生成质量差的章节
- 前后矛盾的情况
- 状态压缩丢失关键信息的情况

**分类问题**：
- Prompt 问题：指令不清楚、缺少示例
- 状态管理问题：关键信息丢失、状态结构不合理
- LLM 能力问题：模型本身的限制

### 2. 优化 Prompt

**世界观设计的 Prompt**：
- 如何引导用户从模糊想法到具体设定
- 如何问出关键信息（人物、冲突、背景）

**章节生成的 Prompt**：
- 如何利用世界观和前面章节的信息
- 如何保持风格一致

**状态压缩的 Prompt**：
- 如何提取关键信息（不遗漏、不冗余）
- 如何结构化输出

### 3. 优化状态管理

**根据观测结果调整**：
- 如果发现某些信息经常丢失，调整状态结构（增加字段）
- 如果发现状态太冗余，优化压缩策略
- 如果发现上下文还是太长，调整加载策略（比如只加载最近 3 章）

### 4. 建立反馈循环

**流程**：
1. 找出失败案例
2. 分析原因
3. 优化 Prompt 或状态管理
4. 重新跑失败案例
5. 对比优化前后的效果

**产出**：
- 失败案例分析报告（至少 3 个案例）
- 优化前后的对比（成功率、生成质量、Token 消耗）
- 优化后的 Prompt 和状态管理代码

**判断标准**：
- 至少完成一轮优化
- 成功率有提升（哪怕只提升 10%）
- 或者：Token 消耗降低、生成质量提升

---

## 阶段 4：整合交付（第 8-10 周）

**目标**：整合所有模块，做一个可演示的完整平台

**要做的事**：

### 1. 完整流程跑通

**世界观设计流程**：
- 用户输入模糊想法
- Agent 多轮对话引导
- 生成完整世界观文档
- 用户确认

**章节创作流程**：
- Agent 根据世界观生成章节
- 用户修改/重写/确认
- 状态压缩，保存确认态
- 继续下一章

**确保**：
- 状态管理正常（上下文可控）
- 观测性完整（能回放任务）
- 迭代优化的成果已应用

### 2. 加基础的版本管理

**功能**：
- 每次生成章节时，保存版本
- 用户可以查看历史版本
- 用户可以回退到某个版本

**不做**：
- 不做复杂的分支管理
- 不做自动合并

### 3. 准备演示材料

**架构图**：
- 模块划分：世界观设计、章节创作、状态管理、观测性
- 数据流：用户输入 → Agent 处理 → 状态更新 → 输出

**案例**：
- 完整的创作流程演示（从想法到 3 章小说）
- 展示人机协作的过程（用户修改、Agent 重写）
- 展示状态管理的效果（上下文可控、信息不丢失）

**日志**：
- 展示观测性（任务回放）
- 展示迭代优化的效果（优化前后对比）

**产出**：
- 完整的小说创作平台（可运行、可演示）
- 演示材料（架构图、案例、日志）
- 至少 1 部完整的短篇小说（3-5 章）

**判断标准**：
- 能从头到尾跑通一个完整的创作流程
- 有至少 2 个成功案例可展示
- 能演示状态管理和观测性的核心能力

---

## 阶段 5：文档与总结（第 11-12 周）

**目标**：整理文档，准备面试展示

**要做的事**：

### 1. 清理代码
- 删掉调试代码、临时文件
- 加必要的注释（只在关键逻辑处）

### 2. 写项目文档

**项目介绍**：
- 做了什么：人机协作的小说创作平台
- 解决了什么问题：
  - 帮用户从模糊想法到具体设定
  - 支持长篇创作（通过分层状态管理）
  - 可观测、可迭代

**架构设计**：
- 模块划分：世界观设计、章节创作、状态管理、观测性
- 数据流：用户 → Agent → 状态 → 输出
- 状态管理：创作态 vs 确认态、状态压缩、状态加载

**核心能力**：
- **上下文管理**：分层状态管理，解决上下文爆炸问题
- **观测性**：结构化日志、任务回放、指标统计
- **迭代优化**：基于观测结果优化 Prompt 和状态管理

**失败案例与优化**：
- 展示你发现的问题
- 展示你的分析过程
- 展示你的优化方案和效果

### 3. 准备面试材料

**5 分钟介绍**：
- 项目背景：为什么做这个
- 核心能力：上下文管理、观测性、迭代优化
- 亮点：分层状态管理解决上下文爆炸

**10 分钟演示**：
- 跑一个完整案例（从想法到 3 章小说）
- 展示状态管理（上下文可控）
- 展示观测性（任务回放）
- 展示迭代优化（优化前后对比）

**常见问题准备**：
- 为什么这样设计状态管理？
- 遇到过什么坑？
- 如何优化的？
- 如果要扩展到多 Agent 协作，怎么做？
- 如果要支持多部作品管理，怎么做？

**产出**：
- 完整项目文档
- 面试演示材料
- 常见问题的回答

**判断标准**：
- 文档能让别人看懂你做了什么
- 演示能在 10 分钟内展示核心能力
- 能回答"企业级 Agent 和普通 Agent 的区别"

---

## 关键原则

1. **MVP 优先**：不追求完美，先做出能跑的版本
2. **问题驱动**：每个阶段都在解决上一个阶段暴露的问题
3. **可观测**：看不见就改不了，观测性是基础
4. **可迭代**：根据数据优化，不是凭感觉
5. **真实场景**：人机协作创作是真实的、复杂度够的场景
6. **分层状态管理**：这是企业级 Agent 的核心能力之一

---

## 不做什么

1. **不做多 Agent 协作**：MVP 只需要单 Agent
2. **不做多部作品管理**：只做单部小说
3. **不做自动评估**：人工评估质量就够了（后面可以加）
4. **不做复杂的版本管理**：简单的历史版本就够了
5. **不做 RAG**：MVP 不需要外部知识库（后面可以加）
6. **不做复杂的协作功能**：不做多人协作、不做评论系统

---

## 技术栈

- **LangChain**：Agent 核心、Memory、Prompt 管理
- **LangGraph**：状态管理、流程编排（推荐，因为需要复杂的状态转换）
- **Python**：开发语言
- **日志**：结构化日志（JSON）
- **存储**：本地文件或数据库（状态、日志、生成的小说）

---

## 成功标准

3 个月后，你能：
1. 演示一个完整的人机协作小说创作平台
2. 解释分层状态管理的设计和实现
3. 展示观测性和迭代优化的效果
4. 回答"企业级 Agent 和普通 Agent 的区别"：
   - 普通 Agent：能跑，但上下文管理混乱、不可观测、不可迭代
   - 企业级 Agent：分层状态管理、完整的观测性、基于数据的迭代优化

这就是企业级 Agent 的核心能力。
